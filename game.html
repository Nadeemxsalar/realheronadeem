<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Color Tile Puzzle+</title>
  <style>
    * { box-sizing: border-box; }
    body {
      margin: 0;
      font-family: 'Segoe UI', sans-serif;
      background: linear-gradient(to right, #1f1c2c, #928dab);
      color: white;
      display: flex;
      flex-direction: column;
      align-items: center;
      min-height: 100vh;
      overflow: hidden;
    }
    h1 {
      margin-top: 20px;
      font-size: 2.5rem;
      text-shadow: 1px 1px 5px black;
    }
    #goalTitle {
      margin: 10px;
      font-size: 20px;
      font-weight: bold;
      transition: color 0.5s ease;
    }
    #grid, #goal {
      display: grid;
      gap: 5px;
      margin: 10px;
      z-index: 1;
    }
    .tile {
      width: 60px;
      height: 60px;
      border-radius: 10px;
      transition: background 0.3s, transform 0.2s;
      cursor: pointer;
      box-shadow: 0 0 8px rgba(0,0,0,0.3);
    }
    .tile:hover {
      transform: scale(1.05);
    }
    .tile:active {
      transform: scale(0.95);
    }
    .button-bar {
      margin: 10px;
    }
    button {
      margin: 5px;
      padding: 10px 15px;
      font-size: 14px;
      background: #00bcd4;
      border: none;
      border-radius: 6px;
      color: white;
      cursor: pointer;
      box-shadow: 0 3px 6px rgba(0,0,0,0.3);
    }
    #timer, #scoreDisplay {
      font-size: 16px;
      margin: 5px;
    }
    .hinted {
      border: 3px dashed white;
    }
    .score-box {
      display: flex;
      gap: 15px;
      align-items: center;
      margin-bottom: 10px;
    }
  </style>
</head>
<body>
  <h1>Color Tile Puzzle+</h1>
  <div id="goalTitle">üéØ Match this pattern:</div>
  <div id="goal"></div>

  <div id="levelDisplay">Level: 1</div>
  <div class="score-box">
    <div id="timer">‚è± Time: 5:00</div>
    <div id="scoreDisplay">‚≠ê Score: 0</div>
  </div>

  <div id="grid"></div>
  <div class="button-bar">
    <button onclick="resetLevel()">Reset</button>
    <button onclick="showHint()">Hint</button>
    <button onclick="undoLastMove()">Undo</button>
  </div>

  <script>
    const colors = ["#e74c3c", "#3498db", "#2ecc71", "#f1c40f"];
    let level = 1;
    let gridSize = 3;
    let grid = [];
    let goal = [];
    let previousStates = [];
    let score = 0;
    let timeLeft = 300; // 5 minutes
    let timerInterval;

    const gridContainer = document.getElementById("grid");
    const goalContainer = document.getElementById("goal");
    const goalLabel = document.getElementById("goalTitle");
    const levelDisplay = document.getElementById("levelDisplay");
    const timerDisplay = document.getElementById("timer");
    const scoreDisplay = document.getElementById("scoreDisplay");

    function createGrid(size) {
      clearInterval(timerInterval);
      timeLeft = 300;
      timerDisplay.textContent = `‚è± Time: 5:00`;
      timerInterval = setInterval(() => {
        timeLeft--;
        let minutes = Math.floor(timeLeft / 60);
        let seconds = timeLeft % 60;
        timerDisplay.textContent = `‚è± Time: ${minutes}:${seconds.toString().padStart(2, '0')}`;
        if (timeLeft === 0) {
          clearInterval(timerInterval);
          alert("‚è∞ Time's up! Try again.");
          resetLevel();
        }
      }, 1000);

      previousStates = [];
      gridContainer.innerHTML = "";
      goalContainer.innerHTML = "";
      grid = [];
      goal = [];
      gridContainer.style.gridTemplateColumns = `repeat(${size}, 60px)`;
      goalContainer.style.gridTemplateColumns = `repeat(${size}, 60px)`;

      for (let i = 0; i < size * size; i++) {
        const tile = document.createElement("div");
        const goalTile = document.createElement("div");

        let colorIndex = Math.floor(Math.random() * colors.length);
        let goalColorIndex = Math.floor(Math.random() * colors.length);

        tile.classList.add("tile");
        goalTile.classList.add("tile");

        tile.style.background = colors[colorIndex];
        goalTile.style.background = colors[goalColorIndex];

        tile.dataset.colorIndex = colorIndex;
        goalTile.dataset.colorIndex = goalColorIndex;

        tile.addEventListener("click", () => {
          previousStates.push(grid.map(t => t.dataset.colorIndex));
          let index = (parseInt(tile.dataset.colorIndex) + 1) % colors.length;
          tile.dataset.colorIndex = index;
          tile.style.background = colors[index];
          checkWin();
        });

        grid.push(tile);
        goal.push(goalTile);

        gridContainer.appendChild(tile);
        goalContainer.appendChild(goalTile);
      }

      animateLabelColor();
    }

    function checkWin() {
      let matched = true;
      for (let i = 0; i < grid.length; i++) {
        if (grid[i].dataset.colorIndex !== goal[i].dataset.colorIndex) {
          matched = false;
          break;
        }
      }
      if (matched) {
        clearInterval(timerInterval);
        score += level * timeLeft * 10;
        scoreDisplay.textContent = `‚≠ê Score: ${score}`;
        setTimeout(() => {
          level++;
          gridSize = Math.min(6, 3 + Math.floor(level / 2));
          levelDisplay.textContent = `Level: ${level}`;
          createGrid(gridSize);
        }, 1000);
      }
    }

    function resetLevel() {
      createGrid(gridSize);
    }

    function undoLastMove() {
      if (previousStates.length > 0) {
        let last = previousStates.pop();
        grid.forEach((tile, idx) => {
          tile.dataset.colorIndex = last[idx];
          tile.style.background = colors[last[idx]];
        });
      }
    }

    function showHint() {
      for (let i = 0; i < grid.length; i++) {
        if (grid[i].dataset.colorIndex !== goal[i].dataset.colorIndex) {
          grid[i].classList.add("hinted");
          setTimeout(() => grid[i].classList.remove("hinted"), 1000);
          break;
        }
      }
    }

    function animateLabelColor() {
      goalLabel.style.color = colors[Math.floor(Math.random() * colors.length)];
    }

    createGrid(gridSize);
  </script>
</body>
</html>
